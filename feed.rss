<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel><title>Marcos Cobeña Morián</title>
<description>I write software to solve people's problems</description>
<link>https://marcoscobena.com</link>
<item>
  <title>Xamarin.Forms XAML</title>
  <guid>https://marcoscobena.com/?i=xf-xaml</guid>
  <description>&lt;p&gt;In the same way we continuously refactor our C# code we should trait XAML one equally. As we layout screens there uses to be pieces which can be reused here and there. After some years working with Xamarin.Forms —plus some more with WPF and co.— I've learnt from others, and my own experience, how to scaffold good XAML which maintains its good shape as time goes by.&lt;/p&gt;

&lt;p&gt;Split into chapters, I'll try to cover everything expressed in XAML:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml"&gt;Xaml Styler and App structure (this one)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-colors"&gt;Colors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-control-templates"&gt;Control Templates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-converters"&gt;Converters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-font-styles"&gt;Font Styles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-global-styles"&gt;Global Styles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-sizes"&gt;Sizes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-styles"&gt;Styles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Xaml Styler&lt;/h3&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/danimart1991"&gt;Daniel Martín&lt;/a&gt; we've been using &lt;a href="https://github.com/Xavalon/XamlStyler"&gt;Xaml Styler&lt;/a&gt; in &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile/tree/develop/Source/Tools/XamlStyler"&gt;our last project&lt;/a&gt;. Xaml Styler's not StyleCop: it doesn't throw errors on bad formatting but rewrites everything to conform the guidelines. My mate &lt;a href="https://twitter.com/jacano35"&gt;Juan Antonio Cano&lt;/a&gt; &lt;a href="https://github.com/jacano/XamlStyler"&gt;forked it&lt;/a&gt; and added the "verify" option: now it can be used within a build pipeline and stop such on styling errors. For us App Center's &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile/blob/develop/Source/TailwindTraders.Mobile/TailwindTraders.Mobile.Android/appcenter-post-clone.sh"&gt;post-clone scripts&lt;/a&gt; have fit superb.&lt;/p&gt;

&lt;p&gt;Since I work entirely on macOS there's no built-in option for Xaml Styler at Visual Studio for Mac, so I came up with this Custom Tool which I quickly run by &lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;X&lt;/code&gt; &lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;S&lt;/code&gt; —I passed from having a Terminal which runs a bash script into this, which's a good step:&lt;/p&gt;

&lt;p&gt;&lt;img src="items/images/XamlStylerCustomTool.png" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The full Arguments: &lt;code&gt;../Tools/XamlStyler/XamlStyler.Console/xstyler.exe -c CodeAnalysis/XamlStylerSettings.json -d . -r true&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile/blob/develop/Source/TailwindTraders.Mobile/CodeAnalysis/XamlStylerSettings.json"&gt;Xaml Styler's JSON&lt;/a&gt; has still stuff to do with Visual Studio for Windows which could ideally be ripped in favor of a more agnostic flavour; however, they hurt nothing.&lt;/p&gt;

&lt;p&gt;My only concern currently is why Visual Studio for Mac doesn't like setting the column width to 2 spaces, and continuously tries to make me work at 4. This' something I still have to study deeper.&lt;/p&gt;

&lt;p&gt;Appart from above, these are some other rules I try to follow:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;120 chars per line; it helps us work with multiple files openned as columns —and is consistent with the same rule on C# files&lt;/li&gt;
&lt;li&gt;Empty lines around XML nodes: look below how for instance &lt;code&gt;Label&lt;/code&gt; breezes inside the &lt;code&gt;ContentView&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```xaml
&lt;ContentView VerticalOptions="Start"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ContentView.Padding&amp;gt;

    &amp;lt;Thickness
        Top="{StaticResource DefaultMargin}"
        Right="{StaticResource DefaultMargin}"
        Bottom="{StaticResource DefaultMargin}" /&amp;gt;

&amp;lt;/ContentView.Padding&amp;gt;

&amp;lt;Label x:Name="theLabel"
    Text="{Binding Key}"
    Style="{StaticResource 20BoldFontStyle}"
    TextColor="{StaticResource WhiteColor}" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/ContentView&gt;
```&lt;/p&gt;

&lt;h3&gt;App.xaml&lt;/h3&gt;

&lt;p&gt;At the opposite of what we'd think, I've found better with time to leave this file "empty". The quotes mean it's actually not empty, but blends other sources which do have XAML of value inside.&lt;/p&gt;

&lt;p&gt;This, for example, is a typical App.xaml:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;Application 
    xmlns="http://xamarin.com/schemas/2014/forms"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:local="clr-namespace:XamarinCrumbs.XamarinForms"
    x:Class="XamarinCrumbs.XamarinForms.App"&amp;gt;
    &amp;lt;Application.Resources&amp;gt;
        &amp;lt;ResourceDictionary&amp;gt;
            &amp;lt;ResourceDictionary.MergedDictionaries&amp;gt;
                &amp;lt;local:Colors /&amp;gt;
                &amp;lt;local:ControlTemplates /&amp;gt;
                &amp;lt;local:Converters /&amp;gt;
                &amp;lt;local:FontStyles /&amp;gt;
                &amp;lt;local:GlobalStyles /&amp;gt;
                &amp;lt;local:Sizes /&amp;gt;
                &amp;lt;local:Styles /&amp;gt;
            &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt;
        &amp;lt;/ResourceDictionary&amp;gt;
    &amp;lt;/Application.Resources&amp;gt;
&amp;lt;/Application&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Whoever may open this file for the first time will quickly know how stuff's placed within the project.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Thu, 20 Dec 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Exceptions to Exceptions (Xamarin)</title>
  <guid>https://marcoscobena.com/?i=exceptions-to-exceptions</guid>
  <description>&lt;p&gt;A few weeks? ago I read &lt;a href="https://people.gnome.org/~federico/blog/propagating-errors.html"&gt;Federico's post&lt;/a&gt; on how they're handling errors with Rust —moving from C to Rust in librsvg, one the Gnome core libraries. I liked the article by it-self, because analyzes from 0 different approaches and, in the end, points to another one on how Midori did the same —for those who like me didn't know what Midori was: a Microsoft Research project to vertically analyze how an OS could be rewritten in managed code.&lt;/p&gt;

&lt;p&gt;When making apps with Xamarin, and I guess this' shared among every framework, there's a moment when you need to retrieve data from an API, making a HTTP call, and things can go wrong.&lt;/p&gt;

&lt;p&gt;One of my first implementations was something similar to —imagine we're in a ViewModel:&lt;/p&gt;

&lt;p&gt;```c#
private async Task LoadDataAsync()
{
    ResultDTO result;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try
{
    // Think of refitAPI as a static readonly field
    result = await refitAPI.GetAsync();
}
catch (Exception exception)
{
    await DisplayAlertAsync("Ops, something went wrong. Thanks for your patience.");
}

if (result == null)
{
    return;
}

// Here we assign result to a prop binded to the view
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;From the user perspective she shouldn't worry because anything that could go wrong is handled, although is presented with a generic valueless alert. It can also happen the API call ends just fine but it returns &lt;code&gt;null&lt;/code&gt; —it can happen if the JSON payload is empty, for instance. We should tell the user something about this too...&lt;/p&gt;

&lt;p&gt;My desk-mate &lt;a href="https://twitter.com/sescaladab"&gt;Sergio&lt;/a&gt; shared with me his tooling to better handle all this stuff, which we've been using in &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile"&gt;Tailwind Traders&lt;/a&gt;, where the API call is boxed and a more appropriate return value is obtained:&lt;/p&gt;

&lt;p&gt;```c#
private async Task LoadDataAsync()
{
    var result = await TryExecuteWithLoadingIndicatorsAsync(refitAPI.GetAsync);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!result.IsSucceeded || result.Result == null)
{
    return;
}

// Here we assign result to a prop binded to the view
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;This' a great improvement because:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we no longer are in charge of handling the different exceptions on each API call;&lt;/li&gt;
&lt;li&gt;when having such, there's a standard way to present such to our users;&lt;/li&gt;
&lt;li&gt;the returning value has better semantics —i.e. &lt;code&gt;IsSucceeded&lt;/code&gt;; and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsBusy&lt;/code&gt; is handled too so it'll end up on a loading overlay giving feedback&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While I was reading Federico's article, and Midori one, it called my attention how we were using a somewhat similar approach to them —saving the distance—, but they both have a language which's richer in error handling. Our, C#, heavily works on unchecked exceptions: each method can return any exception and there's no way of noticing that in develop-time:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we can read the method documentation header, as we use to do with such coming from the .NET Framework it-self; or&lt;/li&gt;
&lt;li&gt;we can disassemble it and see what it's internally doing, although we can't guarantee there's a inner call which does throw any other one&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java, for instance, forces developers to explicitly type which exceptions a method may throw. It's quite verbose —it's been ~10 years since I don't write Java code— but makes us think what to do with them.&lt;/p&gt;

&lt;p&gt;Using the hype those articles promoted in my interior I went to NuGet home and typed "Rust" in the search box. I found &lt;a href="https://www.nuget.org/packages/CSharp.OperationResult"&gt;CSharp.OperationResult&lt;/a&gt; project, which takes Rust approach into C# and, while I don't see the point on heavily relying in such everywhere in our projects, I do see its great value with above examples.&lt;/p&gt;

&lt;p&gt;(Its owner has merged our &lt;a href="https://github.com/gnaeus/OperationResult/pull/1#issuecomment-447576656"&gt;PR moving the lib into .NET Standard&lt;/a&gt; and there'll be a new NuGet soon.)&lt;/p&gt;

&lt;p&gt;This week I've spent a few hours rewriting our &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile/blob/feature/163-product-detail/Source/TailwindTraders.Mobile/TailwindTraders.Mobile/Framework/TaskHelper.cs"&gt;TaskHelper&lt;/a&gt; class by moving from our &lt;code&gt;WrapResult&lt;/code&gt; class to &lt;code&gt;Result&lt;/code&gt; and &lt;code&gt;Status&lt;/code&gt;, which reduces even more the code needed at ViewModel level but makes beautiful the one at the inner implementation:&lt;/p&gt;

&lt;p&gt;```c#
public async Task&lt;Result&lt;T&gt;&gt; TryWithErrorHandlingAsync&lt;T&gt;(
    Task&lt;T&gt; task,
    Func&lt;Exception, Task&lt;bool&gt;&gt; customErrorHandler = null)
{
    whenStarting?.Invoke();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!connectivityService.IsThereInternet)
{
    loggingService?.Warning("There's no Internet access");
    return Error();
}

try
{
    T actualResult = await task;
    return Ok(actualResult);
}
// Here goes multiple catches for each error scenario, alerting users accordingly

whenFinished?.Invoke();

return Error();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;From above method perspective anyone can quickly understand where things are leaving OK and where don't: &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Error&lt;/code&gt; methods speak for them-selves. But, more important, consumers from outside don't have to worry on catching exceptions, but wiring the result or alerting valuable information on what went wrong and could they could do then.&lt;/p&gt;

&lt;p&gt;I think am personally in a phase where don't want to fill my code of try/catch everywhere, I prefer to leave things happen while I'm developing and, trust time will tell me which exceptions I should worry on. I too see the point on protecting that sensible stuff which could definitely go wrong don't know currently why however. I'm curious on what other feel on this area, which's the pros and cons of their work with errors and what are the findings while walking in that direction.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Fri, 14 Dec 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Styles</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-styles</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Styles.xaml&lt;/h3&gt;

&lt;p&gt;Headers, bodies, captions... all these are suitable elements to style because may appear in different XAMLs and share common properties.&lt;/p&gt;

&lt;p&gt;Are you looking for Key-less styles? &lt;a href="?i=xf-xaml-global-styles"&gt;GlobalStyles.xaml&lt;/a&gt; is your place.&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Key: {Identifier}{TargetType}Style

&lt;ul&gt;
&lt;li&gt;TargetType may look redundant but it really helps avoiding coming back here to know such&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following's just an example of styles I've worked with in different apps lately:&lt;/p&gt;

&lt;p&gt;```xaml
&lt;Style x:Key="DefaultButtonStyle"
    TargetType="Button"&gt;
    &lt;Setter Property="BackgroundColor" Value="White" /&gt;
    &lt;Setter Property="FontFamily" Value="{StaticResource BrandonGrotesqueMedium}" /&gt;
    &lt;Setter Property="FontSize" Value="Medium" /&gt;
    &lt;Setter Property="Padding"&gt;
      &lt;Thickness
        Left="{StaticResource Default2Margin}"
        Right="{StaticResource Default2Margin}" /&gt;
    &lt;/Setter&gt;
    &lt;Setter Property="TextColor" Value="{StaticResource AccentColor}" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style x:Key="AccentColorButtonStyle"
    BasedOn="{StaticResource DefaultButtonStyle}"
    TargetType="Button"&gt;
    &lt;Setter Property="BackgroundColor" Value="{StaticResource AccentColor}" /&gt;
    &lt;Setter Property="TextColor"&gt;White&lt;/Setter&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style x:Key="Accent2ColorButtonStyle"
    BasedOn="{StaticResource AccentColorButtonStyle}"
    TargetType="Button"&gt;
    &lt;Setter Property="BackgroundColor" Value="{StaticResource Accent2Color}" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style x:Key="TitleLabelStyle"
    TargetType="Label"
    BasedOn="{StaticResource 12BoldFontStyle}"&gt;
    &lt;Setter Property="Margin"&gt;
        &lt;Thickness
            Top="{StaticResource DefaultMargin}"
            Bottom="{StaticResource DefaultMargin}"/&gt;
    &lt;/Setter&gt;
    &lt;Setter Property="TextColor" Value="{StaticResource DefaultTextColor}" /&gt;
&lt;/Style&gt;
```&lt;/p&gt;

&lt;p&gt;However, take into account whether would make more sense to style in native. One example: a button which you accomplish through a &lt;code&gt;Label&lt;/code&gt; plus a &lt;code&gt;TapGestureRecognizer&lt;/code&gt;. In that case, Android app would loose Material Design haptics, and in the same way iOS' one the corresponding. So, it's better to style in native to assure we don't forget those differences each platform offers us.&lt;/p&gt;

&lt;p&gt;Are you looking for styling &lt;code&gt;Grid&lt;/code&gt;'s columns or rows? You can't actually do this; however, can define rows and columns definitions which really accomplish the same:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;Grid 
    ColumnDefinitions="{StaticResource MyColumnDefinition}"&amp;gt;
    [...]
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Conventions:
- Key: {Identifier}{ColumnOrRow}Definition&lt;/p&gt;

&lt;p&gt;NOTE: adding comments on each row/column definition's helpful to later understand what's used for&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;ColumnDefinitionCollection x:Key="MyColumnDefinition"&amp;gt;
    &amp;lt;!-- Rate of interest --&amp;gt;
    &amp;lt;ColumnDefinition /&amp;gt;
    &amp;lt;!-- Stretch --&amp;gt;
    &amp;lt;ColumnDefinition /&amp;gt;
    &amp;lt;!-- Bonus --&amp;gt;
    &amp;lt;ColumnDefinition /&amp;gt;
    &amp;lt;!-- Balance --&amp;gt;
    &amp;lt;ColumnDefinition /&amp;gt;
&amp;lt;/ColumnDefinitionCollection&amp;gt;
&lt;/code&gt;&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Wed, 21 Nov 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Sizes</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-sizes</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Sizes.xaml&lt;/h3&gt;

&lt;p&gt;This' the perfect place for sizes: margins, paddings, spacings, font sizes, etc. It's quite common designs rely in recurrent sizes to place stuff, thus are suitable to be reused —Designers use to call this "working on the grid" :-)&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Key: {Negative?}{Adjective}{Identifier}{Type}, where Type stands for Margin, Padding, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```xaml
&lt;x:Double x:Key="DefaultMargin"&gt;16&lt;/x:Double&gt;
&lt;x:Int32 x:Key="DefaultMarginInt"&gt;16&lt;/x:Int32&gt;
&lt;!-- Notice how we've defined the negative version, as it's neat for disabling outer margins, f.e. --&gt;
&lt;x:Double x:Key="NegativeDefaultMargin"&gt;-16&lt;/x:Double&gt;
&lt;x:Int32 x:Key="NegativeDefaultMarginInt"&gt;-16&lt;/x:Int32&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="0.5xDefaultMargin"&gt;8&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="2xDefaultMargin"&gt;32&lt;/x:Double&gt;
&lt;x:Double x:Key="Negative2xDefaultMargin"&gt;-32&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="3xDefaultMargin"&gt;48&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="4xDefaultMargin"&gt;64&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="Default2Margin"&gt;24&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;!-- This can be handy if you drop shadows through PlatformConfigurations' VisualElement.Elevation --&gt;
&lt;x:Int32 x:Key="DefaultElevation"&gt;30&lt;/x:Int32&gt;
```&lt;/p&gt;

&lt;p&gt;I like to ask Designers during the first days which's their default grid size, and then start building above list up on such value —for instance above relies in 16, the default one.&lt;/p&gt;

&lt;p&gt;It may not be significant if you've never used this approach before; however, it enforces the grid along every page, pushing a sense of visual coherence —at least for those like me who are highly sensitive to this stuff.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Mon, 19 Nov 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Global Styles</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-global-styles</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;GlobalStyles.xaml&lt;/h3&gt;

&lt;p&gt;Wouldn't be great to default &lt;code&gt;StackLayout&lt;/code&gt;'s &lt;code&gt;Spacing&lt;/code&gt; to 0 everywhere, or having every &lt;code&gt;Label&lt;/code&gt; a default font size and color? Less code to write, easier refactorings. All these fit here perfectly.&lt;/p&gt;

&lt;p&gt;You may ask: why default controls' spacing, padding, margin, etc. to 0? Because, personally, when working with Design specs it helps a lot to just take into account those sizes I explicitly type.&lt;/p&gt;

&lt;p&gt;```xaml
&lt;!-- This exposes DefaultButtonStyle as the predefined one for every Button --&gt;
&lt;Style
  BasedOn="{StaticResource DefaultButtonStyle}"
  TargetType="Button" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style TargetType="Entry"&gt;
  &lt;Setter Property="TextColor" Value="{StaticResource AccentColor}" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style TargetType="Frame"&gt;
  &lt;Setter Property="HasShadow" Value="false" /&gt;
  &lt;Setter Property="Padding" Value="0" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style TargetType="Grid"&gt;
  &lt;Setter Property="ColumnSpacing" Value="0" /&gt;
  &lt;Setter Property="RowSpacing" Value="0" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;!-- This sets font-related settings to every Label --&gt;
&lt;Style
  BasedOn="{StaticResource BrandonGrotesqueMediumMediumFontStyle}"
  TargetType="Label"&gt;
  &lt;Setter Property="TextColor" Value="{StaticResource AccentColor}" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style TargetType="StackLayout"&gt;
  &lt;Setter Property="Spacing" Value="0" /&gt;
&lt;/Style&gt;
```&lt;/p&gt;

&lt;p&gt;Are you looking for Key-full styles? &lt;a href="?i=xf-xaml-styles"&gt;Styles.xaml&lt;/a&gt; is your place.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Tue, 13 Nov 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Font Styles</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-font-styles</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;FontStyles.xaml&lt;/h3&gt;

&lt;p&gt;Dealing with fonts can be a tricky part: because the app shows font faces different from the respective OS' ones, or because the Design specs have multiple sizes, for example.&lt;/p&gt;

&lt;p&gt;You can define here every font the app may need. This will help you refactor sizes, for instance, much more easier —although for sizes I strongly recommend to consider &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.namedsize?view=xamarin-forms"&gt;named sizes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Conventions:
- Key: {FontKey}{FontSize}{FontAttributes}{TargetType}Style&lt;/p&gt;

&lt;p&gt;It may be the case you need external fonts, so you can define such this way, using it as a font family:&lt;/p&gt;

&lt;p&gt;```xaml
&lt;OnPlatform 
    x:Key="LatoRegular"
    x:TypeArguments="x:String"
    Android="Lato-Regular.ttf#Lato"
    iOS="Lato-Regular" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style 
    x:Key="LatoRegular12RegularLabelStyle"
    TargetType="Label"&gt;
    &lt;Setter 
        Property="FontSize" 
        Value="12" /&gt;
&lt;/Style&gt;
```&lt;/p&gt;

&lt;p&gt;Notice how this one depends on its regular flavour, through inheritance —we don't want to rewrite stuff:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;Style
    x:Key="LatoRegular12BoldLabelStyle"
    TargetType="Label"
    BasedOn="{StaticResource LatoRegular12RegularLabelStyle}"&amp;gt;
    &amp;lt;Setter
        Property="FontAttributes"
        Value="Bold" /&amp;gt;
&amp;lt;/Style&amp;gt;
&lt;/code&gt;&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Thu, 08 Nov 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Converters</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-converters</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Converters.xaml&lt;/h3&gt;

&lt;p&gt;I think it's no new for anyone. If a particular converter's used only on a single XAML, just define it there. However, for those in more than one, having them here will help you adding new ones.&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Key: &lt;code&gt;nameof(YourActualConverter).Replace("Converter", string.Empty)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The reason why "Converter" is ripped from the key comes from better readability when using them in XAML: it just feels nicer things like —the word already appears a few times:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;IsEnabled="{Binding ImagePath, Converter={StaticResource StringEmptyToBool}, ConverterParameter=inverse}"&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​    I think will keep here all those I reuse from project to project:    &lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;converters:&lt;/code&gt;&lt;a href="https://github.com/MarcosCobena/XamarinCrumbs/blob/master/XamarinCrumbs/XamarinForms/Converters/AnyConverter.cs"&gt;AnyConverter&lt;/a&gt;&lt;code&gt;x:Key="Any" /&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;converters:&lt;/code&gt;&lt;a href="https://github.com/MarcosCobena/XamarinCrumbs/blob/master/XamarinCrumbs/XamarinForms/Converters/AreEqualsConverter.cs"&gt;AreEqualsConverter&lt;/a&gt;&lt;code&gt;x:Key="AreEquals" /&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;converters:&lt;/code&gt;&lt;a href="https://github.com/MarcosCobena/XamarinCrumbs/blob/master/XamarinCrumbs/XamarinForms/Converters/IsStringNullOrWhiteSpaceConverter.cs"&gt;IsStringNullOrWhiteSpaceConverter&lt;/a&gt;&lt;code&gt;x:Key="IsStringNullOrWhiteSpace" /&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;converters:&lt;/code&gt;&lt;a href="https://github.com/MarcosCobena/XamarinCrumbs/blob/master/XamarinCrumbs/XamarinForms/Converters/NotConverter.cs"&gt;NotConverter&lt;/a&gt;&lt;code&gt;x:Key="Not" /&amp;gt;&lt;/code&gt;&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Tue, 30 Oct 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Control Templates</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-control-templates</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;ControlTemplates.xaml&lt;/h3&gt;

&lt;p&gt;&lt;img src="items/images/pine-watt-412305-unsplash.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Photo by &lt;a href="https://unsplash.com/photos/3_Xwxya43hE?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;pine  watt&lt;/a&gt; on &lt;a href="https://unsplash.com/search/photos/frame?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Unsplash&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;As it uses to happen, I learned what Control Templates were during a big refactoring involving styles. When you're going through the screens designed, don't you realize there's a common pattern? If you do, try to group all those things shared into Control Templates, because will frame your pages letting such concentrate just in the inner content.&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Key: {Identifier}Template&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to consume them, just add those at page's definition:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;ContentPage 
    [...]
    ControlTemplate="{StaticResource FullScreenLoadingTemplate}"&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This one's particularly handy, as can make any page loading-aware:&lt;/p&gt;

&lt;p&gt;```xaml
&lt;ControlTemplate x:Key="FullScreenLoadingTemplate"&gt;
    &lt;AbsoluteLayout&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;ContentPresenter
        AbsoluteLayout.LayoutFlags="All"
        AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
        IsVisible="{TemplateBinding BindingContext.IsBusy, Converter={StaticResource NotConverter}}" /&amp;gt;

    &amp;lt;ContentView
        AbsoluteLayout.LayoutFlags="All"
        AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
        IsVisible="{TemplateBinding BindingContext.IsBusy}"&amp;gt;

        &amp;lt;ActivityIndicator
            IsRunning="true"
            HorizontalOptions="Center"
            VerticalOptions="Center" /&amp;gt;

    &amp;lt;/ContentView&amp;gt;

&amp;lt;/AbsoluteLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/ControlTemplate&gt;
```&lt;/p&gt;

&lt;p&gt;Another scenario where I found these quite useful's pages with custom nav bars —i.e. you don't want predefined OS one. Instead of stacking once and again your "CustomNavBarControl" it can be done just once, worrying on the actual changing content.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Wed, 17 Oct 2018 22:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Colors</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-colors</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Colors.xaml&lt;/h3&gt;

&lt;p&gt;Every color's placed here: it's super convenient to have all together, it helps us identify repeated ones, for instance. We try to keep them order alphabetically, although it's not a must: simply helps some of us to quickly locate them —in C# we have a drop-down menu just on top of the editor to navigate between members, but currently, VS for Mac at least, doesn't have any similar.&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Key: {Identifier}Color for &lt;code&gt;Color&lt;/code&gt; or {Identifier}ColorString for &lt;code&gt;string&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Value: lowercase hex format (you can opt for uppercase, but choosing one will keep consistency)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RGB most of the times, although ARGB works pretty well in scenarios where backgrounds are semitransparent, or gradients too&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```xaml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ResourceDictionary 
    xmlns="http://xamarin.com/schemas/2014/forms" 
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" 
    x:Class="XamarinCrumbs.XamarinForms.Colors"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Color x:Key="AccentColor"&amp;gt;#50e3c2&amp;lt;/Color&amp;gt;
&amp;lt;x:String x:Key="AccentColorString"&amp;gt;#50e3c2&amp;lt;/x:String&amp;gt;

&amp;lt;Color x:Key="DefaultTextColor"&amp;gt;#abb3c8&amp;lt;/Color&amp;gt;

&amp;lt;Color x:Key="SecondaryTextColor"&amp;gt;#868ea4&amp;lt;/Color&amp;gt;

&amp;lt;Color x:Key="WhiteColor"&amp;gt;#ffffff&amp;lt;/Color&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/ResourceDictionary&gt;
```&lt;/p&gt;

&lt;p&gt;You've probably asked your-self why WhiteColor's defined when there's already White in &lt;code&gt;Xamarin.Forms.Color&lt;/code&gt;: sometimes it's intelligent to "duplicate" them for supporting future tonality changes, f.e.&lt;/p&gt;

&lt;p&gt;Moreover, you've seen in above XAML there's the same color twice: it makes sense when you need to consume such for controls like &lt;a href="https://github.com/luberda-molinet/FFImageLoading"&gt;FFImageLoading&lt;/a&gt;'s, which don't accept a &lt;code&gt;Color&lt;/code&gt;, but a &lt;code&gt;string&lt;/code&gt; in hex format.&lt;/p&gt;

&lt;p&gt;Although I've personally prefered naming colors by their actual value (LightGreenColor, for example), I've ended up choosing those which give a hint on where they're applied: DefaultTextColor, SeparatorColor, things like these.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PS.&lt;/em&gt;: On 2017 I wrote this small thing, &lt;a href="?i=abanico-a-few-hours-with-xamarin-forms-and-skiasharp"&gt;Abanico&lt;/a&gt;, to understand how color wheels work. It's Xamarin.Forms too, with SkiaSharp:&lt;/p&gt;

&lt;p&gt;&lt;img src="items/images/jun-21-2017-22-47-38.gif" alt="" /&gt;&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Tue, 09 Oct 2018 22:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms Design Framework</title>
  <guid>https://marcoscobena.com/?i=Xamarin-Forms-Design-Framework-b23a2f12cce5</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post was imported, please &lt;a href="#/contact"&gt;contact&lt;/a&gt; me if there's anything wrong with it. Thanks in advance)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Xamarin.Forms Design Framework&lt;/h3&gt;

&lt;p&gt;In my personal trip to leverage all those small problems I found in my day to day, there’s one which sistematically reappears: I’m about to start a new Xamarin.Forms project for X platforms — please note the plural — but just have its design for one of them. For instance: I want my app to target Android &amp;amp; iOS, but just have the Android design.&lt;/p&gt;

&lt;p&gt;The reasons why this happen would give for a different thread but I feel them as an homogeneus mix of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Xamarin.Forms’ missunderstood, or we didn’t explain it quite well: it’s felt like Flutter — it appeared! — when it’s not&lt;/li&gt;
&lt;li&gt;We don’t want to increase the time and money by spending a few more days with the rest of designs, for one reason or another we don’t see its valueI’ve been thinking a lot on this and nowadays have a strong opinnion which proposes one possible exit:&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;&lt;strong&gt;Xamarin.Forms Design Framework&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Most of the times, when I’m working with a Zeplin project for a Forms app, the first servers as a handful guide of margins/paddings, sizes and colors. It’s not so much whether the status bar has a particular background color, or the button has any tweak which makes it look different. Obviously, those are things which in the end need to be done, but aren’t at the top of value.&lt;/p&gt;

&lt;p&gt;Imagine we had something like &lt;a href="http://design.xamarin.com"&gt;http://design.xamarin.com&lt;/a&gt; where our Designers could head on and learn without the first scroll what actually Xamarin.Forms’ all about. In their language.&lt;/p&gt;

&lt;p&gt;After this, it could propose a Design Framework which would isolate from platform specifics and would concentrate on letting Designers express our apps in an agnostic way. A quick example to explain this: a button in such Framework would be a flat box with text inside: as a Developer, I can gather its width &amp;amp; height, its relative position to the parent view, margins with close controls, padding with its internal title and even its font size &amp;amp; color, which could also be done latter by Platform Translators.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://cdn-images-1.medium.com/max/1000/0*t7UJdpwx2KGsTC1N" alt="" /&gt;&lt;br /&gt;
Photo by &lt;a href="https://unsplash.com/@halgatewood?utm_source=medium&amp;amp;utm_medium=referral"&gt;Hal Gatewood&lt;/a&gt; on &lt;a href="https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral"&gt;Unsplash&lt;/a&gt;&lt;br /&gt;
Platform Translators are the pieces which our Designer could fulfill to tell us how buttons should look like in iOS, in a closer aspect, or which’s the predominant font family to use in Android.&lt;/p&gt;

&lt;p&gt;Such Design Framework could be seen as an imaginary device which focuses on wireframing, and then could have it’s Forms backend, letting us express the UIs internally with XAML.&lt;/p&gt;

&lt;p&gt;Even more, all this also sets the scenario up for something like a WYSIWYG editor, where XAML brights, now yes, serving as a bridge where Designers and Developers can interact. XAML was conceived with this in mind more than a decade ago but the reality is it’s heavily focused on just Developers. Let’s change this.&lt;/p&gt;

&lt;p&gt;Designers could have templates for Sketch or PhotoShop where every control is just there to drag &amp;amp; drop into their designs, in the same way there are toolkits for the most known platforms.&lt;/p&gt;

&lt;p&gt;The truth’s we are moving into an ecosystem where our apps can be mobile or desktop or cloud, but such can’t only rely in the Development side. If we don’t make our Designers happier — with its direct impact on the later development — we’ll keep having a very beatiful app on X, with a “free” version on Y and Z.&lt;/p&gt;

&lt;p&gt;And the best: there’s nothing to change on Forms. There’s nothing dependant on development tools, or SDKs. Sketching’s nothing new. It’s more of a mind change.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Sun, 10 Jun 2018 22:00:00 GMT</pubDate>
</item></channel>
</rss>