<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel><title>Marcos Cobeña Morián</title>
<description>I write software to solve people's problems</description>
<link>https://marcoscobena.com</link>
<item>
  <title>Pull-Request reviews</title>
  <guid>https://marcoscobena.com/?i=pr-reviews</guid>
  <description>&lt;p&gt;I've being feeling lately am spending too much effort in cosmetic stuff which add low value instead of concentrating in logic, algorithms.&lt;/p&gt;

&lt;p&gt;Serve this as my personal reminder for how to take a PR review:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If I detect something doesn't conform the style guidelines, instead of adding a comment:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;think of enforcing such rule in any way: through Git hooks, StyleCop, etc. It's important to consider how much time you'd earn by enabling such instead of once and again adding similar comments in future PRs; or&lt;/li&gt;
&lt;li&gt;add an in-line comment to leverage this which, indeed, will arrive to the rest of team as well: for example:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```c#
// Marcos says: below fields are ordered alphabetically to easily allow us search
public const string AppCenterKey = "bar";&lt;/p&gt;

&lt;p&gt;public const string APIKey = "foo";
```&lt;/p&gt;

&lt;p&gt;​ ; or&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;simply write this down in any communication channel your team has: a Slack/Teams conversation, during tomorrow daily, etc.; or&lt;/li&gt;
&lt;li&gt;forget your impulse, just keep scrolling down because there for sure will be things far more interesting to consider&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Tue, 19 Feb 2019 23:00:00 GMT</pubDate>
</item>
<item>
  <title>GoTo</title>
  <guid>https://marcoscobena.com/?i=goto</guid>
  <description>&lt;p&gt;While I was studying Computer Science had one subject named Computability Theory where it was introduced a quite simple, at the beginning, language: GOTO. Its target was to demonstrate whether a function could be expressed using such —then called GOTO-computable— thus such could be calculated by a computer. (My teachers may kill me because how I've summed things up but think it's somewhat valid :-)&lt;/p&gt;

&lt;p&gt;By that time I wrote an interpreter in JavaScript (which may reside in one of my multiple back-ups) and quickly sent it to my teachers, thinking maybe any student could eventually find it useful. My programming abilities were weak by then and, for instance, I relied the parsing on regular expressions —you can imagine how strong my implementation was...&lt;/p&gt;

&lt;p&gt;A few months ago, and pushed by &lt;a href="https://praeclarum.org/2018/08/27/oops-i-wrote-a-c-compiler.html"&gt;Fran Krueger's CLanguage article&lt;/a&gt;, I found it attractive to spent my spare time working on a more solid compiler which, how not, would target .NET ecosystem. Also because I've always had curiosity on how &lt;code&gt;System.Reflection.Emit&lt;/code&gt; works and saw a chance to learn it deeper.&lt;/p&gt;

&lt;h4&gt;Language&lt;/h4&gt;

&lt;p&gt;GOTO's quite simple: you add or subtract 1, jump anywhere or nothing —this' one the aspects why I said it can fit for children. This could be the Hello World in GOTO:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Y = Y + 1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The vars you can play with are simple too: input ones, aux ones and one output. And I'm sure you've already figured their notations out: &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt;, in the same order.&lt;/p&gt;

&lt;p&gt;The entire language specification can be found &lt;a href="https://github.com/MarcosCobena/GoTo/wiki/Language"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h4&gt;Parsing&lt;/h4&gt;

&lt;p&gt;Also during University I learned Antlr, through Java, up to building a small BASIC interpreter. After some Google-ing I discovered there's a .NET backend for it, which's .NET Standard by the way, so decided to go with it as my parsing infrastructure.&lt;/p&gt;

&lt;p&gt;The only language definition I have's the one my teachers still use in Computer Science and Mathematics courses, which's formal in its description but lacks a formal side to be used for actual programming, so my first steps were popping a grammar with lexer and parser rules of what I wanted to achieve. As an example, this' the way conditional instructions are detected:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
instruction : [...]
    | 'IF' var=ID '!=' '0' 'GOTO' label=ID #ConditionalInstruction
    [...]
    ;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I've iterated a lot the grammar during this time, refactoring once and again, reaching a point where it feels comfortable for further passes such like the semantic one.&lt;/p&gt;

&lt;h4&gt;Semantic Analysis&lt;/h4&gt;

&lt;p&gt;There are a bunch of rules which aren't permitted in GOTO, for instance using different vars in the same instruction:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
X2 = X3 + 1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Hey, I told you GOTO was simple! Allowing above, however, can be easily achieved with something we'll see later on; however, it's not allowed by definition.&lt;/p&gt;

&lt;p&gt;The semantic analysis, along with the lexing and parsing, produces error messages. You're already familiar with compiler errors and recognize the line, column and message they use to come with. I've based my-self on this idea for GOTO too, where the compiler returns a collection of messages with that information and, for the sake of future iterations, its severity: error or simply a warning —truth be told I've still not used this last :-D&lt;/p&gt;

&lt;h4&gt;Abstract Syntax Tree&lt;/h4&gt;

&lt;p&gt;My initial idea was to directly throw IL while visiting the parsing tree and, quickly, noticed it wasn't the best way to go. I needed to build an AST: a parsing-free tree representation which's ready for further steps, i.e. code generation.&lt;/p&gt;

&lt;p&gt;Lucky of me GOTO's so small a flat collection of nodes do the job quite good in my opinion: instead of having an AST it actually manages instruction nodes where, now yes, are helpful by the time of translating into IL.&lt;/p&gt;

&lt;p&gt;As a curious thing, I've ended up solving one or two semantic analysis over the "AST" instead of before, because simply having this new data structure's made easier the job: GOTO doesn't allow referencing labels in conditional instructions which aren't defined anywhere (I've allowed before or after, both), and checking this' something like:&lt;/p&gt;

&lt;p&gt;```c#
public static void CheckMissingLabel(ProgramNode program, ref List&lt;Message&gt; messages)
{
    var conditionals = program.Instructions
        .Where(item =&gt; item is ConditionalInstructionNode node &amp;amp;&amp;amp; 
            !node.TargetLabel.Equals(Settings.ExitLabel.ToString()))
        .Cast&lt;ConditionalInstructionNode&gt;();
    var labels = program.Instructions
        .Cast&lt;InstructionNode&gt;()
        .Select(item =&gt; item.Label);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach (var item in conditionals)
{
    if (!labels.Contains(item.TargetLabel))
    {
        var message = new Message(
            SeverityEnum.Error,
            $"The conditional instruction cannot target missing label {item.TargetLabel}.",
            item.Line,
            item.Column);
        messages.Add(message);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h4&gt;Code Generation&lt;/h4&gt;

&lt;p&gt;Let's say our program has no errors and we're ready to throw IL —Intermediate Language, the byte-code .NET runtime understands. My idea's always been to have a CLI interface —&lt;em&gt;a la&lt;/em&gt; Microsoft's &lt;code&gt;csc&lt;/code&gt;, Mono's &lt;code&gt;mcs&lt;/code&gt;— where I could compile programs quickly. However, while the time passed, I noticed also wanted to quickly run my programs, so had to decide what I actually wanted to generate.&lt;/p&gt;

&lt;p&gt;The main, and think only, difference between EXE and DLL files in .NET resides in the first having an entry-point on where the CLR knows has to start executing; the DLLs simply don't have such. If I wanted to allow people reuse their programs with, let's say, F# an EXE wouldn't be so useful, but yes a DLL: it can be consumable everywhere —except under iOS devices, although have to double-check this, because of Frank's Continuous. In the other hand, a DLL can't be easily runnable: I'd have to create a new project, reference such and write code to call it.&lt;/p&gt;

&lt;p&gt;I decided to stick with the DLL. It's curious how &lt;a href="http://www.drdobbs.com/generating-code-at-run-time-with-reflect/184416570"&gt;the best article I read&lt;/a&gt; to leverage my &lt;code&gt;System.Reflection.Emit&lt;/code&gt; knowledge's been this from 2002! Even I still have serious concerns whether was the same article I read seventeen years ago (17)... Good stuff never passes by.&lt;/p&gt;

&lt;p&gt;Summing up: I've copied &lt;code&gt;dotnet&lt;/code&gt; command idea, and provided the handy &lt;code&gt;gotool&lt;/code&gt; one:&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gotool
  GOTO-ol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Usage: gotool.exe option ...
- option: build, run&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;If you want to build a program just pass "build" and the program path and go. Once you have the output DLL, just pass "run", the DLL path and an input value and go. This'd be a typical session:&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;type HelloWorld.goto
  Y = Y + 1
  gotool build HelloWorld.goto
  GOTO-ol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Success! HelloWorld.dll&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gotool run HelloWorld.dll 0
  GOTO-ol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1
```&lt;/p&gt;

&lt;h4&gt;Macros&lt;/h4&gt;

&lt;p&gt;For example, GOTO allows conditional instructions asking whether a var is 0 but, could we turn such inconditional —i.e. independant of the value? Sure:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Z = Z + 1
IF Z != 0 GOTO L
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This' known as the GOTO macro. Then, how can we use it?&lt;/p&gt;

&lt;p&gt;Simply consider it as any other instruction within a program:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
GOTO A
Y = Y + 1
[A] X = X + 1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Because I had no origin on how macros could be expressed in a formal way —with formal I mean doable with a computer— I ended up creating a simple schema, where macros are defined by replacing those symbols at its signature:&lt;/p&gt;

&lt;p&gt;```
MACRO GOTO L
Z = Z + 1
IF Z != 0 GOTO L
END&lt;/p&gt;

&lt;p&gt;GOTO A
Y = Y + 1
[A] X = X + 1
```&lt;/p&gt;

&lt;h4&gt;IDE&lt;/h4&gt;

&lt;p&gt;Saying I've been working on an IDE for GoTo's very pretentious I guess. Having the CLI wasn't so much funny for me as having something in the browser where I could start writing GOTO and running it by a single click.&lt;/p&gt;

&lt;p&gt;I had already played with Frank's Ooui and since my daily job consists on 99% Xamarin.Forms it's been a pleasure path to travel by.&lt;/p&gt;

&lt;p&gt;Although my initial idea was to rely in WebAssembly —mostly to avoid any different hosting from my web one— I couldn't take this road because &lt;code&gt;System.Reflection&lt;/code&gt; dependencies aren't supported in that scenario. What did I do then? No problem, Ooui offers an ASP.NET backend which communicates through Web Sockets. And this way GoTo Studio, as I named it, has been working until yesterday night.&lt;/p&gt;

&lt;p&gt;One of the bugs I had was the lack of control on infinite loops: it's not a problem with the CLI, but it's actually one with Web Sockets: my Azure App Service tier (the free one) provided 5 simultaneous connections so blocking such with 5 different endless loops made the entire website break.&lt;/p&gt;

&lt;p&gt;Two days ago I started writing a small interpreter —I really like to call it a Virtual Machine— which, taking advantage of the AST representation, runs the program step by step. Since now I have control on such, I've set a limit on the steps to, now yes, break those infinite loops on time.&lt;/p&gt;

&lt;p&gt;To assure programs compiled into IL and run by .NET CLR have the same results as those interpreted by its own VM I made some small changes into the Unit Tests, where the same set passes —and actually pass in green— for both.&lt;/p&gt;

&lt;p&gt;You can now use &lt;a href="https://marcoscobena.com/goto-studio/"&gt;GoTo Studio&lt;/a&gt; without worry on leaving it useless :-)&lt;/p&gt;

&lt;h4&gt;Conclusions&lt;/h4&gt;

&lt;p&gt;I've learned a lot with this personal project and above I discuss most of the technical aspects I've touched. However, it's in the human side where I most gain I think: having something I do just for pleasure and which doesn't conform to any rule further than providing joy to my-self is being a beautiful discover.&lt;/p&gt;

&lt;p&gt;While working on this I got the idea —a bunch of ideas actually— this could serve for children to learn programming, and this motivates me even more to continue ~~working~~ playing.&lt;/p&gt;

&lt;p&gt;Thanks to my mates at Plain Concepts which detected some bugs and helped me making GoTo Studio easier to use. And to my beautiful fiancee for encouraging me to go deep on this: I'd really like, one day, to teach our children how computer works with this project :,-)&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Thu, 03 Jan 2019 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML</title>
  <guid>https://marcoscobena.com/?i=xf-xaml</guid>
  <description>&lt;p&gt;In the same way we continuously refactor our C# code we should trait XAML one equally. As we layout screens there uses to be pieces which can be reused here and there. After some years working with Xamarin.Forms —plus some more with WPF and co.— I've learnt from others, and my own experience, how to scaffold good XAML which maintains its good shape as time goes by.&lt;/p&gt;

&lt;p&gt;Split into chapters, I'll try to cover everything expressed in XAML:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml"&gt;Xaml Styler and App structure (this one)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-colors"&gt;Colors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-control-templates"&gt;Control Templates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-converters"&gt;Converters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-font-styles"&gt;Font Styles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-global-styles"&gt;Global Styles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-sizes"&gt;Sizes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="?i=xf-xaml-styles"&gt;Styles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Xaml Styler&lt;/h3&gt;

&lt;p&gt;Thanks to &lt;a href="https://twitter.com/danimart1991"&gt;Daniel Martín&lt;/a&gt; we've been using &lt;a href="https://github.com/Xavalon/XamlStyler"&gt;Xaml Styler&lt;/a&gt; in &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile/tree/develop/Source/Tools/XamlStyler"&gt;our last project&lt;/a&gt;. Xaml Styler's not StyleCop: it doesn't throw errors on bad formatting but rewrites everything to conform the guidelines. My mate &lt;a href="https://twitter.com/jacano35"&gt;Juan Antonio Cano&lt;/a&gt; &lt;a href="https://github.com/jacano/XamlStyler"&gt;forked it&lt;/a&gt; and added the "verify" option: now it can be used within a build pipeline and stop such on styling errors. For us App Center's &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile/blob/develop/Source/TailwindTraders.Mobile/TailwindTraders.Mobile.Android/appcenter-post-clone.sh"&gt;post-clone scripts&lt;/a&gt; have fit superb.&lt;/p&gt;

&lt;p&gt;Since I work entirely on macOS there's no built-in option for Xaml Styler at Visual Studio for Mac, so I came up with this Custom Tool which I quickly run by &lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;X&lt;/code&gt; &lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;S&lt;/code&gt; —I passed from having a Terminal which runs a bash script into this, which's a good step:&lt;/p&gt;

&lt;p&gt;&lt;img src="items/images/XamlStylerCustomTool.png" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The full Arguments: &lt;code&gt;../Tools/XamlStyler/XamlStyler.Console/xstyler.exe -c CodeAnalysis/XamlStylerSettings.json -d . -r true&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile/blob/develop/Source/TailwindTraders.Mobile/CodeAnalysis/XamlStylerSettings.json"&gt;Xaml Styler's JSON&lt;/a&gt; has still stuff to do with Visual Studio for Windows which could ideally be ripped in favor of a more agnostic flavour; however, they hurt nothing.&lt;/p&gt;

&lt;p&gt;My only concern currently is why Visual Studio for Mac doesn't like setting the column width to 2 spaces, and continuously tries to make me work at 4. This' something I still have to study deeper.&lt;/p&gt;

&lt;p&gt;Appart from above, these are some other rules I try to follow:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;120 chars per line; it helps us work with multiple files openned as columns —and is consistent with the same rule on C# files&lt;/li&gt;
&lt;li&gt;Empty lines around XML nodes: look below how for instance &lt;code&gt;Label&lt;/code&gt; breezes inside the &lt;code&gt;ContentView&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```xaml
&lt;ContentView VerticalOptions="Start"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ContentView.Padding&amp;gt;

    &amp;lt;Thickness
        Top="{StaticResource DefaultMargin}"
        Right="{StaticResource DefaultMargin}"
        Bottom="{StaticResource DefaultMargin}" /&amp;gt;

&amp;lt;/ContentView.Padding&amp;gt;

&amp;lt;Label x:Name="theLabel"
    Text="{Binding Key}"
    Style="{StaticResource 20BoldFontStyle}"
    TextColor="{StaticResource WhiteColor}" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/ContentView&gt;
```&lt;/p&gt;

&lt;h3&gt;App.xaml&lt;/h3&gt;

&lt;p&gt;At the opposite of what we'd think, I've found better with time to leave this file "empty". The quotes mean it's actually not empty, but blends other sources which do have XAML of value inside.&lt;/p&gt;

&lt;p&gt;This, for example, is a typical App.xaml:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;Application 
    xmlns="http://xamarin.com/schemas/2014/forms"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:local="clr-namespace:XamarinCrumbs.XamarinForms"
    x:Class="XamarinCrumbs.XamarinForms.App"&amp;gt;
    &amp;lt;Application.Resources&amp;gt;
        &amp;lt;ResourceDictionary&amp;gt;
            &amp;lt;ResourceDictionary.MergedDictionaries&amp;gt;
                &amp;lt;local:Colors /&amp;gt;
                &amp;lt;local:ControlTemplates /&amp;gt;
                &amp;lt;local:Converters /&amp;gt;
                &amp;lt;local:FontStyles /&amp;gt;
                &amp;lt;local:GlobalStyles /&amp;gt;
                &amp;lt;local:Sizes /&amp;gt;
                &amp;lt;local:Styles /&amp;gt;
            &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt;
        &amp;lt;/ResourceDictionary&amp;gt;
    &amp;lt;/Application.Resources&amp;gt;
&amp;lt;/Application&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Whoever may open this file for the first time will quickly know how stuff's placed within the project.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Thu, 20 Dec 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Exceptions to Exceptions (Xamarin)</title>
  <guid>https://marcoscobena.com/?i=exceptions-to-exceptions</guid>
  <description>&lt;p&gt;A few weeks? ago I read &lt;a href="https://people.gnome.org/~federico/blog/propagating-errors.html"&gt;Federico's post&lt;/a&gt; on how they're handling errors with Rust —moving from C to Rust in librsvg, one the Gnome core libraries. I liked the article by it-self, because analyzes from 0 different approaches and, in the end, points to another one on how Midori did the same —for those who like me didn't know what Midori was: a Microsoft Research project to vertically analyze how an OS could be rewritten in managed code.&lt;/p&gt;

&lt;p&gt;When making apps with Xamarin, and I guess this' shared among every framework, there's a moment when you need to retrieve data from an API, making a HTTP call, and things can go wrong.&lt;/p&gt;

&lt;p&gt;One of my first implementations was something similar to —imagine we're in a ViewModel:&lt;/p&gt;

&lt;p&gt;```c#
private async Task LoadDataAsync()
{
    ResultDTO result;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try
{
    // Think of refitAPI as a static readonly field
    result = await refitAPI.GetAsync();
}
catch (Exception exception)
{
    await DisplayAlertAsync("Ops, something went wrong. Thanks for your patience.");
}

if (result == null)
{
    return;
}

// Here we assign result to a prop binded to the view
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;From the user perspective she shouldn't worry because anything that could go wrong is handled, although is presented with a generic valueless alert. It can also happen the API call ends just fine but it returns &lt;code&gt;null&lt;/code&gt; —it can happen if the JSON payload is empty, for instance. We should tell the user something about this too...&lt;/p&gt;

&lt;p&gt;My desk-mate &lt;a href="https://twitter.com/sescaladab"&gt;Sergio&lt;/a&gt; shared with me his tooling to better handle all this stuff, which we've been using in &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile"&gt;Tailwind Traders&lt;/a&gt;, where the API call is boxed and a more appropriate return value is obtained:&lt;/p&gt;

&lt;p&gt;```c#
private async Task LoadDataAsync()
{
    var result = await TryExecuteWithLoadingIndicatorsAsync(refitAPI.GetAsync);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!result.IsSucceeded || result.Result == null)
{
    return;
}

// Here we assign result to a prop binded to the view
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;This' a great improvement because:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we no longer are in charge of handling the different exceptions on each API call;&lt;/li&gt;
&lt;li&gt;when having such, there's a standard way to present such to our users;&lt;/li&gt;
&lt;li&gt;the returning value has better semantics —i.e. &lt;code&gt;IsSucceeded&lt;/code&gt;; and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsBusy&lt;/code&gt; is handled too so it'll end up on a loading overlay giving feedback&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While I was reading Federico's article, and Midori one, it called my attention how we were using a somewhat similar approach to them —saving the distance—, but they both have a language which's richer in error handling. Our, C#, heavily works on unchecked exceptions: each method can return any exception and there's no way of noticing that in develop-time:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we can read the method documentation header, as we use to do with such coming from the .NET Framework it-self; or&lt;/li&gt;
&lt;li&gt;we can disassemble it and see what it's internally doing, although we can't guarantee there's a inner call which does throw any other one&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java, for instance, forces developers to explicitly type which exceptions a method may throw. It's quite verbose —it's been ~10 years since I don't write Java code— but makes us think what to do with them.&lt;/p&gt;

&lt;p&gt;Using the hype those articles promoted in my interior I went to NuGet home and typed "Rust" in the search box. I found &lt;a href="https://www.nuget.org/packages/CSharp.OperationResult"&gt;CSharp.OperationResult&lt;/a&gt; project, which takes Rust approach into C# and, while I don't see the point on heavily relying in such everywhere in our projects, I do see its great value with above examples.&lt;/p&gt;

&lt;p&gt;(Its owner has merged our &lt;a href="https://github.com/gnaeus/OperationResult/pull/1#issuecomment-447576656"&gt;PR moving the lib into .NET Standard&lt;/a&gt; and there'll be a new NuGet soon.)&lt;/p&gt;

&lt;p&gt;This week I've spent a few hours rewriting our &lt;a href="https://github.com/Microsoft/TailwindTraders-Mobile/blob/feature/163-product-detail/Source/TailwindTraders.Mobile/TailwindTraders.Mobile/Framework/TaskHelper.cs"&gt;TaskHelper&lt;/a&gt; class by moving from our &lt;code&gt;WrapResult&lt;/code&gt; class to &lt;code&gt;Result&lt;/code&gt; and &lt;code&gt;Status&lt;/code&gt;, which reduces even more the code needed at ViewModel level but makes beautiful the one at the inner implementation:&lt;/p&gt;

&lt;p&gt;```c#
public async Task&lt;Result&lt;T&gt;&gt; TryWithErrorHandlingAsync&lt;T&gt;(
    Task&lt;T&gt; task,
    Func&lt;Exception, Task&lt;bool&gt;&gt; customErrorHandler = null)
{
    whenStarting?.Invoke();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!connectivityService.IsThereInternet)
{
    loggingService?.Warning("There's no Internet access");
    return Error();
}

try
{
    T actualResult = await task;
    return Ok(actualResult);
}
// Here goes multiple catches for each error scenario, alerting users accordingly

whenFinished?.Invoke();

return Error();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;From above method perspective anyone can quickly understand where things are leaving OK and where don't: &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Error&lt;/code&gt; methods speak for them-selves. But, more important, consumers from outside don't have to worry on catching exceptions, but wiring the result or alerting valuable information on what went wrong and could they could do then.&lt;/p&gt;

&lt;p&gt;I think am personally in a phase where don't want to fill my code of try/catch everywhere, I prefer to leave things happen while I'm developing and, trust time will tell me which exceptions I should worry on. I too see the point on protecting that sensible stuff which could definitely go wrong don't know currently why however. I'm curious on what other feel on this area, which's the pros and cons of their work with errors and what are the findings while walking in that direction.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Fri, 14 Dec 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Styles</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-styles</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Styles.xaml&lt;/h3&gt;

&lt;p&gt;Headers, bodies, captions... all these are suitable elements to style because may appear in different XAMLs and share common properties.&lt;/p&gt;

&lt;p&gt;Are you looking for Key-less styles? &lt;a href="?i=xf-xaml-global-styles"&gt;GlobalStyles.xaml&lt;/a&gt; is your place.&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Key: {Identifier}{TargetType}Style

&lt;ul&gt;
&lt;li&gt;TargetType may look redundant but it really helps avoiding coming back here to know such&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following's just an example of styles I've worked with in different apps lately:&lt;/p&gt;

&lt;p&gt;```xaml
&lt;Style x:Key="DefaultButtonStyle"
    TargetType="Button"&gt;
    &lt;Setter Property="BackgroundColor" Value="White" /&gt;
    &lt;Setter Property="FontFamily" Value="{StaticResource BrandonGrotesqueMedium}" /&gt;
    &lt;Setter Property="FontSize" Value="Medium" /&gt;
    &lt;Setter Property="Padding"&gt;
      &lt;Thickness
        Left="{StaticResource Default2Margin}"
        Right="{StaticResource Default2Margin}" /&gt;
    &lt;/Setter&gt;
    &lt;Setter Property="TextColor" Value="{StaticResource AccentColor}" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style x:Key="AccentColorButtonStyle"
    BasedOn="{StaticResource DefaultButtonStyle}"
    TargetType="Button"&gt;
    &lt;Setter Property="BackgroundColor" Value="{StaticResource AccentColor}" /&gt;
    &lt;Setter Property="TextColor"&gt;White&lt;/Setter&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style x:Key="Accent2ColorButtonStyle"
    BasedOn="{StaticResource AccentColorButtonStyle}"
    TargetType="Button"&gt;
    &lt;Setter Property="BackgroundColor" Value="{StaticResource Accent2Color}" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style x:Key="TitleLabelStyle"
    TargetType="Label"
    BasedOn="{StaticResource 12BoldFontStyle}"&gt;
    &lt;Setter Property="Margin"&gt;
        &lt;Thickness
            Top="{StaticResource DefaultMargin}"
            Bottom="{StaticResource DefaultMargin}"/&gt;
    &lt;/Setter&gt;
    &lt;Setter Property="TextColor" Value="{StaticResource DefaultTextColor}" /&gt;
&lt;/Style&gt;
```&lt;/p&gt;

&lt;p&gt;However, take into account whether would make more sense to style in native. One example: a button which you accomplish through a &lt;code&gt;Label&lt;/code&gt; plus a &lt;code&gt;TapGestureRecognizer&lt;/code&gt;. In that case, Android app would loose Material Design haptics, and in the same way iOS' one the corresponding. So, it's better to style in native to assure we don't forget those differences each platform offers us.&lt;/p&gt;

&lt;p&gt;Are you looking for styling &lt;code&gt;Grid&lt;/code&gt;'s columns or rows? You can't actually do this; however, can define rows and columns definitions which really accomplish the same:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;Grid 
    ColumnDefinitions="{StaticResource MyColumnDefinition}"&amp;gt;
    [...]
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Conventions:
- Key: {Identifier}{ColumnOrRow}Definition&lt;/p&gt;

&lt;p&gt;NOTE: adding comments on each row/column definition's helpful to later understand what's used for&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;ColumnDefinitionCollection x:Key="MyColumnDefinition"&amp;gt;
    &amp;lt;!-- Rate of interest --&amp;gt;
    &amp;lt;ColumnDefinition /&amp;gt;
    &amp;lt;!-- Stretch --&amp;gt;
    &amp;lt;ColumnDefinition /&amp;gt;
    &amp;lt;!-- Bonus --&amp;gt;
    &amp;lt;ColumnDefinition /&amp;gt;
    &amp;lt;!-- Balance --&amp;gt;
    &amp;lt;ColumnDefinition /&amp;gt;
&amp;lt;/ColumnDefinitionCollection&amp;gt;
&lt;/code&gt;&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Wed, 21 Nov 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Sizes</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-sizes</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Sizes.xaml&lt;/h3&gt;

&lt;p&gt;This' the perfect place for sizes: margins, paddings, spacings, font sizes, etc. It's quite common designs rely in recurrent sizes to place stuff, thus are suitable to be reused —Designers use to call this "working on the grid" :-)&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Key: {Negative?}{Adjective}{Identifier}{Type}, where Type stands for Margin, Padding, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```xaml
&lt;x:Double x:Key="DefaultMargin"&gt;16&lt;/x:Double&gt;
&lt;x:Int32 x:Key="DefaultMarginInt"&gt;16&lt;/x:Int32&gt;
&lt;!-- Notice how we've defined the negative version, as it's neat for disabling outer margins, f.e. --&gt;
&lt;x:Double x:Key="NegativeDefaultMargin"&gt;-16&lt;/x:Double&gt;
&lt;x:Int32 x:Key="NegativeDefaultMarginInt"&gt;-16&lt;/x:Int32&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="0.5xDefaultMargin"&gt;8&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="2xDefaultMargin"&gt;32&lt;/x:Double&gt;
&lt;x:Double x:Key="Negative2xDefaultMargin"&gt;-32&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="3xDefaultMargin"&gt;48&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="4xDefaultMargin"&gt;64&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;x:Double x:Key="Default2Margin"&gt;24&lt;/x:Double&gt;&lt;/p&gt;

&lt;p&gt;&lt;!-- This can be handy if you drop shadows through PlatformConfigurations' VisualElement.Elevation --&gt;
&lt;x:Int32 x:Key="DefaultElevation"&gt;30&lt;/x:Int32&gt;
```&lt;/p&gt;

&lt;p&gt;I like to ask Designers during the first days which's their default grid size, and then start building above list up on such value —for instance above relies in 16, the default one.&lt;/p&gt;

&lt;p&gt;It may not be significant if you've never used this approach before; however, it enforces the grid along every page, pushing a sense of visual coherence —at least for those like me who are highly sensitive to this stuff.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Mon, 19 Nov 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Global Styles</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-global-styles</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;GlobalStyles.xaml&lt;/h3&gt;

&lt;p&gt;Wouldn't be great to default &lt;code&gt;StackLayout&lt;/code&gt;'s &lt;code&gt;Spacing&lt;/code&gt; to 0 everywhere, or having every &lt;code&gt;Label&lt;/code&gt; a default font size and color? Less code to write, easier refactorings. All these fit here perfectly.&lt;/p&gt;

&lt;p&gt;You may ask: why default controls' spacing, padding, margin, etc. to 0? Because, personally, when working with Design specs it helps a lot to just take into account those sizes I explicitly type.&lt;/p&gt;

&lt;p&gt;```xaml
&lt;!-- This exposes DefaultButtonStyle as the predefined one for every Button --&gt;
&lt;Style
  BasedOn="{StaticResource DefaultButtonStyle}"
  TargetType="Button" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style TargetType="Entry"&gt;
  &lt;Setter Property="TextColor" Value="{StaticResource AccentColor}" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style TargetType="Frame"&gt;
  &lt;Setter Property="HasShadow" Value="false" /&gt;
  &lt;Setter Property="Padding" Value="0" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style TargetType="Grid"&gt;
  &lt;Setter Property="ColumnSpacing" Value="0" /&gt;
  &lt;Setter Property="RowSpacing" Value="0" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;!-- This sets font-related settings to every Label --&gt;
&lt;Style
  BasedOn="{StaticResource BrandonGrotesqueMediumMediumFontStyle}"
  TargetType="Label"&gt;
  &lt;Setter Property="TextColor" Value="{StaticResource AccentColor}" /&gt;
&lt;/Style&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style TargetType="StackLayout"&gt;
  &lt;Setter Property="Spacing" Value="0" /&gt;
&lt;/Style&gt;
```&lt;/p&gt;

&lt;p&gt;Are you looking for Key-full styles? &lt;a href="?i=xf-xaml-styles"&gt;Styles.xaml&lt;/a&gt; is your place.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Tue, 13 Nov 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Font Styles</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-font-styles</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;FontStyles.xaml&lt;/h3&gt;

&lt;p&gt;Dealing with fonts can be a tricky part: because the app shows font faces different from the respective OS' ones, or because the Design specs have multiple sizes, for example.&lt;/p&gt;

&lt;p&gt;You can define here every font the app may need. This will help you refactor sizes, for instance, much more easier —although for sizes I strongly recommend to consider &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.namedsize?view=xamarin-forms"&gt;named sizes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Conventions:
- Key: {FontKey}{FontSize}{FontAttributes}{TargetType}Style&lt;/p&gt;

&lt;p&gt;It may be the case you need external fonts, so you can define such this way, using it as a font family:&lt;/p&gt;

&lt;p&gt;```xaml
&lt;OnPlatform 
    x:Key="LatoRegular"
    x:TypeArguments="x:String"
    Android="Lato-Regular.ttf#Lato"
    iOS="Lato-Regular" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;Style 
    x:Key="LatoRegular12RegularLabelStyle"
    TargetType="Label"&gt;
    &lt;Setter 
        Property="FontSize" 
        Value="12" /&gt;
&lt;/Style&gt;
```&lt;/p&gt;

&lt;p&gt;Notice how this one depends on its regular flavour, through inheritance —we don't want to rewrite stuff:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;Style
    x:Key="LatoRegular12BoldLabelStyle"
    TargetType="Label"
    BasedOn="{StaticResource LatoRegular12RegularLabelStyle}"&amp;gt;
    &amp;lt;Setter
        Property="FontAttributes"
        Value="Bold" /&amp;gt;
&amp;lt;/Style&amp;gt;
&lt;/code&gt;&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Thu, 08 Nov 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Converters</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-converters</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Converters.xaml&lt;/h3&gt;

&lt;p&gt;I think it's no new for anyone. If a particular converter's used only on a single XAML, just define it there. However, for those in more than one, having them here will help you adding new ones.&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Key: &lt;code&gt;nameof(YourActualConverter).Replace("Converter", string.Empty)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The reason why "Converter" is ripped from the key comes from better readability when using them in XAML: it just feels nicer things like —the word already appears a few times:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;IsEnabled="{Binding ImagePath, Converter={StaticResource StringEmptyToBool}, ConverterParameter=inverse}"&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​    I think will keep here all those I reuse from project to project:    &lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;converters:&lt;/code&gt;&lt;a href="https://github.com/MarcosCobena/XamarinCrumbs/blob/master/XamarinCrumbs/XamarinForms/Converters/AnyConverter.cs"&gt;AnyConverter&lt;/a&gt;&lt;code&gt;x:Key="Any" /&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;converters:&lt;/code&gt;&lt;a href="https://github.com/MarcosCobena/XamarinCrumbs/blob/master/XamarinCrumbs/XamarinForms/Converters/AreEqualsConverter.cs"&gt;AreEqualsConverter&lt;/a&gt;&lt;code&gt;x:Key="AreEquals" /&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;converters:&lt;/code&gt;&lt;a href="https://github.com/MarcosCobena/XamarinCrumbs/blob/master/XamarinCrumbs/XamarinForms/Converters/IsStringNullOrWhiteSpaceConverter.cs"&gt;IsStringNullOrWhiteSpaceConverter&lt;/a&gt;&lt;code&gt;x:Key="IsStringNullOrWhiteSpace" /&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;converters:&lt;/code&gt;&lt;a href="https://github.com/MarcosCobena/XamarinCrumbs/blob/master/XamarinCrumbs/XamarinForms/Converters/NotConverter.cs"&gt;NotConverter&lt;/a&gt;&lt;code&gt;x:Key="Not" /&amp;gt;&lt;/code&gt;&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Tue, 30 Oct 2018 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Xamarin.Forms XAML: Control Templates</title>
  <guid>https://marcoscobena.com/?i=xf-xaml-control-templates</guid>
  <description>&lt;p&gt;&lt;em&gt;(This post belongs to &lt;a href="?i=xf-xaml"&gt;Xamarin.Forms XAML&lt;/a&gt; series)&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;ControlTemplates.xaml&lt;/h3&gt;

&lt;p&gt;&lt;img src="items/images/pine-watt-412305-unsplash.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Photo by &lt;a href="https://unsplash.com/photos/3_Xwxya43hE?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;pine  watt&lt;/a&gt; on &lt;a href="https://unsplash.com/search/photos/frame?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Unsplash&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;As it uses to happen, I learned what Control Templates were during a big refactoring involving styles. When you're going through the screens designed, don't you realize there's a common pattern? If you do, try to group all those things shared into Control Templates, because will frame your pages letting such concentrate just in the inner content.&lt;/p&gt;

&lt;p&gt;Conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Key: {Identifier}Template&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to consume them, just add those at page's definition:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xaml
&amp;lt;ContentPage 
    [...]
    ControlTemplate="{StaticResource FullScreenLoadingTemplate}"&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This one's particularly handy, as can make any page loading-aware:&lt;/p&gt;

&lt;p&gt;```xaml
&lt;ControlTemplate x:Key="FullScreenLoadingTemplate"&gt;
    &lt;AbsoluteLayout&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;ContentPresenter
        AbsoluteLayout.LayoutFlags="All"
        AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
        IsVisible="{TemplateBinding BindingContext.IsBusy, Converter={StaticResource NotConverter}}" /&amp;gt;

    &amp;lt;ContentView
        AbsoluteLayout.LayoutFlags="All"
        AbsoluteLayout.LayoutBounds="0, 0, 1, 1"
        IsVisible="{TemplateBinding BindingContext.IsBusy}"&amp;gt;

        &amp;lt;ActivityIndicator
            IsRunning="true"
            HorizontalOptions="Center"
            VerticalOptions="Center" /&amp;gt;

    &amp;lt;/ContentView&amp;gt;

&amp;lt;/AbsoluteLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/ControlTemplate&gt;
```&lt;/p&gt;

&lt;p&gt;Another scenario where I found these quite useful's pages with custom nav bars —i.e. you don't want predefined OS one. Instead of stacking once and again your "CustomNavBarControl" it can be done just once, worrying on the actual changing content.&lt;/p&gt;</description>
  <author>marcoscm.digital@gmail.com (Marcos Cobeña Morián)</author>
  <pubDate>Wed, 17 Oct 2018 22:00:00 GMT</pubDate>
</item></channel>
</rss>